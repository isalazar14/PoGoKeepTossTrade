<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <!-- CSS only -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
  <!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous" defer></script> -->
  <style type="text/css">
    body {
      padding-bottom: 20px;
    }

    #content {
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
      padding-bottom: 20px;
    }

    table {
      max-width: 450px;
      background-color: cornflowerblue;
      color: black;
    }

    table#gpuSupport tr.notSupported {
      background-color: slategrey;
      color: yellow;
    }

    th,
    td {
      /* first column */
      padding: 0px 15px;
      text-align: center;
    }

    table td:first-child {
      /* second column */
      text-align: left;
    }

    #calcStatus {
      text-align: center;
    }
  </style>
</head>

<body>
  <noscript>javascript not enabled/supported, can't run calculations</noscript>
  <div id="content">
    <p id='timeNow'></p>
    <p id="cpuCores"></p>

    <table id="settings">
      <h2>Settings</h2>
      <thead>
        <tr>
          <th>Name</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>PF batch size</td>
          <td id="pf-batch-size"></td>
        </tr>
        <tr>
          <td>IV batch size</td>
          <td id="iv-batch-size"></td>
        </tr>
        <tr>
          <td>CP limit </td>
          <td id="cp-limit"></td>
        </tr>
        <tr>
          <td>Max level</td>
          <td id="max-level"></td>
        </tr>
        <tr>
          <td>Target Levels</td>
          <td id="target-levels"></td>
        </tr>
      </tbody>
    </table>
    <table id="performance">
      <h2>Performance (ms)</h2>
      <thead>
        <tr>
          <th>Operation</th>
          <th>CPU</th>
          <th>GPU</th>
          <th>GPU<br><small>(CPU fallback)</small></th>
        </tr>
      </thead>
      <tbody>
        <tr id="maxCalcCPMs">
          <td>Max calc CPMs</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr id="maxValidCPMs">
          <td>Max valid CPMs<br><small>Level at CP limit</small></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr id="stats">
          <td>Calculate stats<br><small>(CP, HP, Atk, Def, SP)</small></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr id="sortSPs">
          <td>Sort SPs</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr id="spPercent">
          <td>Calculate SP%</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
      </tbody>
    </table>
    <div class="d-flex justify-content-center" id="calcStatus">
      <div class="spinner-border" role="status"></div>
    </div>
    <table id="gpuSupport" hidden>
      <h2>GPU Support</h2>
      <thead>
        <tr>
          <th>Feature</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
    <div id="results"></div>
  </div>

  <!-- <script type="text/javascript">
    document.body.append('HELLO FROM SCRIPT')
  </script> -->
  <script src="https://unpkg.com/gpu.js@latest/dist/gpu-browser.min.js"></script>
  <script src="https://unpkg.com/papaparse@5.3.0/papaparse.min.js"></script>
  <!-- <script src="./gpujsTestHelpers.js" type="module" crossorigin="anonymous"></script>
  <script src="./pokeCalcHelpers.js" type="module" crossorigin="anonymous"></script>
  <script src="./pokeCalcsCPU.js" type="module" crossorigin="anonymous"></script>
  <script src="./pokeCalcsGPU.js" type="module" crossorigin="anonymous"></script>
  <script src="./gpujsTest.js" type="module" crossorigin="anonymous"></script> -->
  <!-- <script src="/js/gpujsTest.js" type="module" crossorigin="anonymous"></script> -->
  <script>
    // GPU is a constructor and namespace for browser
    // declare const getCorrectCpms // from "./cpmConverter";, loaded in html
    /* for running WITH bundler (e.g. react app)
        Use import module syntax  */
    // import { GPU, Input } from "gpu.js"
    // import { parse } from "papaparse";
    // import getCorrectCpms from "./cpmConverter";


    // onmessage = (e) =>{
    //   const [gpuG, gpuC] = e.data
    // postMessage("in gpujsTestWorker.js")
    //#region INIT + GLOBAL VARS
    console.log("running gpuTest");
    displayHardwareSupport();
    let calcParams = {
      PF_BATCH_SIZE: 20 /* 0 = no limit */,
      IV_BATCH_SIZE: 20 /* 0 = no limit */,
      CP_LIMIT: 1500,
      MAX_LEVEL: 40,
      TARGET_LEVELS: [30, 40, 41],
      POKEFORMS_CSV_LOCATION_URL:
        // "http://localhost:8000/data/pokemon_forms.csv" // expressServer:
        // "http://localhost:5500/client/src/data/csv/pokemon_forms.csv" // liveServer
        "pokemon_forms.csv",
    };
    console.log(calcParams);
    let pfOptions = {
      preview: calcParams.PF_BATCH_SIZE | 0,
      // pIdRange: [25, 26],
      // pfSelection: ["3,1", "6,1", "9,1"],
    };
    let ivs = createIvMatrix();
    if (calcParams.IV_BATCH_SIZE > 0) ivs = ivs.slice(0, calcParams.IV_BATCH_SIZE);
    // console.log(ivs)
    // prettier-ignore
    const gmCPMs = [0.094, 0.16639787, 0.21573247, 0.25572005, 0.29024988, 0.3210876, 0.34921268, 0.3752356, 0.39956728, 0.4225, 0.44310755, 0.4627984, 0.48168495, 0.49985844, 0.51739395, 0.5343543, 0.5507927, 0.5667545, 0.5822789, 0.5974, 0.6121573, 0.6265671, 0.64065295, 0.65443563, 0.667934, 0.6811649, 0.69414365, 0.7068842, 0.7193991, 0.7317, 0.7377695, 0.74378943, 0.74976104, 0.7556855, 0.76156384, 0.76739717, 0.7731865, 0.77893275, 0.784637, 0.7903, 0.7953, 0.8003, 0.8053, 0.8103, 0.8153, 0.8203, 0.8253, 0.8303, 0.8353, 0.8403, 0.8453];
    let cpmsFloatArray = getCorrectCpms(gmCPMs, "df");
    let maxLevelIdx = calcParams.MAX_LEVEL * 2 - 2;
    let cpmLengthAtMaxLevel = maxLevelIdx + 1;
    cpmsFloatArray = cpmsFloatArray.slice(0, cpmLengthAtMaxLevel);
    // console.log(cpmsFloatArray)

    getPokeForms(calcParams.POKEFORMS_CSV_LOCATION_URL, pfOptions)
      .then(({ headers: pfHeaders, data: pokeForms }) => {
        // console.log(pokeForms);

        if (calcParams.PF_BATCH_SIZE != pokeForms.length)
          calcParams.PF_BATCH_SIZE = pokeForms.length;
        const settingsTable = document.querySelector("table#settings");
        settingsTable.querySelector("#pf-batch-size").innerHTML = calcParams.PF_BATCH_SIZE.toString();
        settingsTable.querySelector("#iv-batch-size").innerHTML = calcParams.IV_BATCH_SIZE.toString();
        settingsTable.querySelector("#cp-limit").innerHTML = calcParams.CP_LIMIT.toString();
        settingsTable.querySelector("#max-level").innerHTML = calcParams.MAX_LEVEL.toString();
        settingsTable.querySelector("#target-levels").innerHTML = calcParams.TARGET_LEVELS.toString();
        /* show settings table */
        document.querySelector("table#settings").removeAttribute("hidden");
        /* SHOW PERFORMANCE TABLE */
        document.querySelector("table#performance").removeAttribute("hidden");
        /* SHOW CALC STATUS SPINNER*/
        const calcStatusDiv = document.querySelector("#calcStatus");
        calcStatusDiv?.querySelector(".spinner-border")?.removeAttribute("hidden");
        //#endregion INIT + GLOBAL VARS
        //#region CREATE GPU KERNELS
        const gpuG = new GPU({ mode: "gpu" });
        const gpuC = new GPU({ mode: "cpu" });
        const calcCp_gpuG = createKernel(gpuG, calcCP, {
          output: [
            cpmsFloatArray.length,
            calcParams.IV_BATCH_SIZE,
            calcParams.PF_BATCH_SIZE,
          ],
        }); // [x, y, z] -> matches this.thread._
        const calcCpmsAtCpLimit_gpuG = createKernel(gpuG, calcCpmsAtCpLimit, {
          output: [calcParams.IV_BATCH_SIZE, calcParams.PF_BATCH_SIZE],
          pipeline: true,
        });
        const calcCpmsAtCpLimit_gpuC = createKernel(gpuC, calcCpmsAtCpLimit, {
          output: [calcParams.IV_BATCH_SIZE, calcParams.PF_BATCH_SIZE],
          pipeline: true,
        });
        const getTrueCpmIdxsFromCalcCpms_gpuG = createKernel(gpuG, getTrueCpmIdxsFromCalcCpms, {
          output: [calcParams.IV_BATCH_SIZE, calcParams.PF_BATCH_SIZE],
          pipeline: true,
        });
        const getTrueCpmIdxsFromCalcCpms_gpuC = createKernel(gpuC, getTrueCpmIdxsFromCalcCpms, {
          output: [calcParams.IV_BATCH_SIZE, calcParams.PF_BATCH_SIZE],
          // pipeline: true /* can this be used in CPU mode?? */
        });
        const getTrueCpmsFromCpmIdxs_gpuG = createKernel(gpuG, getTrueCpmsFromCpmIdxs, {
          output: [calcParams.IV_BATCH_SIZE, calcParams.PF_BATCH_SIZE],
          // pipeline: true
        });
        const getTrueCpmsFromCalcCpms_gpuG = createKernel(gpuG, getTrueCpmsFromCalcCpms, {
          output: [calcParams.IV_BATCH_SIZE, calcParams.PF_BATCH_SIZE],
          // pipeline: true
          // optimizeFLoatMemory: true,
          // tactic: "precision",
        });
        const getTrueCpmsFromCalcCpms_gpuC = createKernel(gpuC, getTrueCpmsFromCalcCpms, {
          output: [calcParams.IV_BATCH_SIZE, calcParams.PF_BATCH_SIZE],
          // pipeline: true
          // optimizeFLoatMemory: true,
          // tactic: "precision",
        });
        //#endregion CREATE GPU KERNELS
        //#region RUN CALCS / PERF TESTS
        // prettier-ignore
        let pokeFormsFlattened = GPU.input(pokeForms.flat(), [pokeForms[0].length, pokeForms.length]);
        // prettier-ignore
        let ivsFlattened = GPU.input(ivs.flat(), [ivs[0].length, ivs.length]);
        // prettier-ignore
        let cpmsFloatArrayFlattened = GPU.input(cpmsFloatArray.flat(), [cpmsFloatArray[0].length, cpmsFloatArray.length]);
        console.log("~~~ calcCpmsAtCpLimit ~~~");
        /* SET CURRENT TEST CELL AS ACTIVE AND SHOW SPINNER */
        const calcTimeRow_maxValidCPMs = document.querySelector("tr#maxValidCPMs");
        const calcTimeRow_calcStats = document.querySelector("tr#stats");
        const calcTimeRow_calcSPs = document.querySelector("tr#sortSPs");
        const calcTimeRow_sortSPs = document.querySelector("tr#spPercent");
        /* NOTE TO SELF: HANDLE SHADOW MONS */
        //#region CPU CALCS
        //#region calcCpms
        // prettier-ignore
        const calcTimeRow_maxCalcCPMs = document.querySelector("tr#maxCalcCPMs");
        let { calcResult: calcCpms_cpu } = runCalcPerfTest("calcCpms_CPU", {
          fn: getCalcCPMsAtCpLimit_CPU,
          fnArgs: [calcParams.CP_LIMIT, pokeForms, ivs],
        }, {
          logResult: true,
          renderPerformance: {
            targetEL: getCalcTimeRowCell(calcTimeRow_maxCalcCPMs, "cpu"),
          },
        });
        /* getTrueCpmsFromCalcCpms_cpu */
        const getTrueCpmFromCalcCpms_cpu_t0 = performance.now();
        let trueCpmsFrpmCalcCpms_cpu = getTrueCpmsFromCalcCpms_CPU(calcCpms_cpu, cpmsFloatArray
          // cpmsFloatArray.length - 1
          // false
        );
        const getTrueCpmFromCalcCpms_cpu_t1 = performance.now();
        const getTrueCpmFromCalcCpms_cpu_dt = getTrueCpmFromCalcCpms_cpu_t1 - getTrueCpmFromCalcCpms_cpu_t0;
        console.log(`getTrueCpmFromCALCCPMs_cpu: ${getTrueCpmFromCalcCpms_cpu_dt} ms`);
        console.log(trueCpmsFrpmCalcCpms_cpu);
        let p = document.createElement("p");
        p.textContent = `getTrueCpmFromCALCCPMs_cpu: ${getTrueCpmFromCalcCpms_cpu_dt} ms`;
        //#endregion RUN calcCpms_CPU, RENDER PERFORMANCE
        //#endregion CPU CALCS
        //#region GPU CALCS
        /* calcCpms_GPU*/
        // prettier-ignore
        const calcTimeCell_maxCalcCPM_GPU = getCalcTimeRowCell(calcTimeRow_maxCalcCPMs, "gpu");
        calcTimeCell_maxCalcCPM_GPU.classList.toggle("running-calc");
        // prettier-ignore
        calcTimeCell_maxCalcCPM_GPU.innerHTML = `<div class="d-flex justify-content-center">
                                          <div class="spinner-border spinner-border-sm" role="status"></div>
                                        </div>`;
        /* RUN CALC calcCpms_GPU*/
        performance.mark("calcCpms_gpuG");
        // prettier-ignore
        const calcCpms_gpuG_texture = calcCpmsAtCpLimit_gpuG(calcParams.CP_LIMIT, pokeForms, ivs);
        // prettier-ignore
        const calcCpms_gpuG_dt = Math.round(performance.measure("calcCpms_gpuG").duration);
        // console.log(calcCpms_gpuG_texture.toArray()); // texture
        console.log(`calcCpms_gpuG (TEXTURE): ${calcCpms_gpuG_dt} ms`);
        /* SET CURRENT TEST CELL AS INACTIVE AND SHOW TIME */
        calcTimeCell_maxCalcCPM_GPU.classList.toggle("running-calc");
        calcTimeCell_maxCalcCPM_GPU.innerHTML = calcCpms_gpuG_dt.toString();
        console.log(calcCpms_gpuG_texture);
        // const calcCpms_gpuC_t0 = performance.now();
        // const calcCpms_gpuC = calcCpmsAtCpLimit_gpuC(calcParams.CP_LIMIT, pokeForms, ivs);
        // const calcCpms_gpuC_t1 = performance.now();
        // const calcCpms_gpuC_dt = calcCpms_gpuC_t1 - calcCpms_gpuC_t0
        // console.log(`calcCpms_gpuC: ${calcCpms_gpuC_dt} ms`);
        // console.log(calcCpms_gpuC, "")
        /* getTrueCpmsFromCalcCpms_gpuC */
        // const getTrueCpmFromCalcCpms_gpuC_t0 = performance.now();
        // let trueCpmsFrpmCalcCpms_gpuC = getTrueCpmsFromCalcCpms_gpuC(calcCpms_gpuC, cpms);
        // const getTrueCpmFromCalcCpms_gpuC_t1 = performance.now();
        // const getTrueCpmFromCalcCpms_gpuC_dt = getTrueCpmFromCalcCpms_gpuC_t1 - getTrueCpmFromCalcCpms_gpuC_t0
        // console.log(`getTrueCpmFromCALCCPMs_gpuC: ${getTrueCpmFromCalcCpms_gpuC_dt} ms`)
        // // console.log(trueCpmsFrpmCalcCpms_gpuC, "");
        // console.log(JSON.stringify(trueCpmsFrpmCalcCpms_gpuC[0].slice(0,10)));
        // p = document.createElement('p')
        // p.textContent=`getTrueCpmFromCALCCPMs_gpuC: ${getTrueCpmFromCalcCpms_gpuC_dt} ms`
        // calcTimeDiv.appendChild(p)
        // document.querySelector('#results').textContent = JSON.stringify(trueCpmsFrpmCalcCpms_gpuC[0].slice(0,10)).replace(/,/g , "\r\n",)
        // const calcTime = t1-t0
        // // console.log("calcCpms\n", calcCpms)
        // // console.log("trueCpms\n", trueCpms)
        // document.querySelector('#performance').innerText = `time to calculate stats for ${calcParams.PF_BATCH_SIZE} pokemon (${(calcParams.PF_BATCH_SIZE*calcParams.IV_BATCH_SIZE).toLocaleString()} calculations): ${(calcTime/1000).toFixed(3)} s`
        // console.log(cps)
        // });
        // }
        // prettier-ignore
        {
          // // getTrueCpmIdxsFromCalcCpms_gpuG
          // const getTrueCpmIdxs_gpuG_t0 = performance.now();
          // let trueCpmIdxs = getTrueCpmIdxsFromCalcCpms_gpuG(calcCpms_gpuG, cpms);
          // const getTrueCpmIdxs_gpuG_t1 = performance.now();
          // console.log(`getTrueCpmIdxs_gpuG: ${getTrueCpmIdxs_gpuG_t1-getTrueCpmIdxs_gpuG_t0} ms`)
          // console.log(trueCpmIdxs) // texture
          // // getTrueCpmsFromCpmIdxs_gpuG
          // const getTrueCpmFromIdxs_gpuG_t0 = performance.now();
          // let trueCpmsFromIdxs = getTrueCpmsFromCpmIdxs_gpuG(trueCpmIdxs, cpms);
          // const getTrueCpmFromIdxs_gpuG_t1 = performance.now();
          // console.log(`getTrueCpmFromIDXs_gpuG: ${getTrueCpmFromIdxs_gpuG_t1-getTrueCpmFromIdxs_gpuG_t0} ms`)
          // console.log(trueCpmsFromIdxs);
        }
        console.log("~~~ getTrueCpmFromCALCCPMs ~~~");
        /* getTrueCpmsFromCalcCpms_gpuG */
        const getTrueCpmFromCalcCpms_gpuG_t0 = performance.now();
        let trueCpmsFrpmCalcCpms_gpuG = getTrueCpmsFromCalcCpms_gpuG(calcCpms_gpuG_texture, cpmsFloatArray, maxLevelIdx, false);
        const getTrueCpmFromCalcCpms_gpuG_t1 = performance.now();
        const getTrueCpmFromCalcCpms_gpuG_dt = getTrueCpmFromCalcCpms_gpuG_t1 - getTrueCpmFromCalcCpms_gpuG_t0;
        console.log(`getTrueCpmFromCALCCPMs_gpuG: ${getTrueCpmFromCalcCpms_gpuG_dt} ms`);
        console.log(trueCpmsFrpmCalcCpms_gpuG);
        // const p = document.createElement("p");
        // p.textContent = `getTrueCpmFromCALCCPMs_gpuG: ${getTrueCpmFromCalcCpms_gpuG_dt} ms`;
        // calcTimeDiv?.appendChild(p);
        // document.querySelector("#results").textContent = JSON.stringify(
        //   trueCpmsFrpmCalcCpms_gpuG[0].slice(0, 10)
        // ).replace(/,/g, "\r\n");
        document.querySelector("#calcStatus").innerHTML = `<p>Done!</p>`;
        //#endregion GPU CALCS
        //#endregion RUN CALCS / PERF TESTS

      }).catch(err => console.error(err))

    function getPokeForms(filePath, options) {
      /* CANNOT USE ASYNC/AWAIT BECAUSE 'parse' FUNCTION RETURNS 'void'.
      MUST USE 'complete' CALLBACK */
      if ((options?.pIdRange && options?.pfSelection) ||
        (options?.pIdRange && options?.preview) ||
        (options?.preview && options?.pfSelection))
        throw new Error("Cannot use more than one option at a time");
      return new Promise((resolve, reject) => {
        Papa.parse(filePath, {
          download: true,
          // header: true, // will turn results into objects with headers (from results 1st row) as properties
          dynamicTyping: true,
          skipEmptyLines: true,
          preview: options?.preview ? options.preview + 1 : 0,
          complete: (parseResults) => {
            /* First row is headers */
            let [headers] = parseResults.data;
            /* Remaining rows are pokeforms */
            let [, ...data] = parseResults.data;
            let result = { headers, data };
            if (options?.preview) {
              /* no options OR preview option set -> pass through results */
              result.data = parseResults.data;
            }
            else if (options?.pIdRange) {
              /* range option set -> get all rows with matching pId, including multiple forms */
              result.data = data.filter((pf) => pf[0] >= options.pIdRange[0] && pf[0] <= options.pIdRange[1]);
            }
            else if (options?.pfSelection) {
              /* selection option set -> get all rows with matching [pId, fId] */
              let selection = options.pfSelection.reduce((map, pf, i) => map.set(pf, true), new Map());
              let rowCount = parseResults.data.length;
              let remaining = options.pfSelection.length;
              let i = 0;
              let filteredPFs = [];
              while (remaining > 0 && i < rowCount) {
                if (selection.has(`${data[i][0]},${data[i][1]}`)) {
                  filteredPFs.push(data[i]);
                  remaining--;
                }
                i++;
              }
              result.data = filteredPFs;
            }
            resolve(result);
            return;
          },
          error: (error) => reject(error),
        });
      });
    }
    function displayHardwareSupport() {
      /* adding gpu features table to DOM */
      let timeEl = document.querySelector("#timeNow");
      if (timeEl != undefined) {
        timeEl.innerHTML = new Date().toLocaleTimeString();
        setInterval(() => {
          timeEl.innerHTML = new Date().toLocaleTimeString();
        }, 1000);
      }
      let cpuEl = document.querySelector("#cpuCores");
      if (cpuEl != undefined) {
        cpuEl.innerHTML = `CPU, total threads: ${navigator.hardwareConcurrency}`;
      }
      const gpuFeatures = [
        "GPU",
        "Kernel Map",
        "Offscreen Canvas",
        "WebGL",
        "WebGL 2",
        "Headless GL",
        "Canvas",
        "GPU HTML Image Array",
        "Single Precision",
      ];
      const gpuSupportTable = document.querySelector("table#gpuSupport");
      // gpuFeatures.forEach(f=>console.log(f, GPU[f]));
      gpuFeatures.forEach((f) => {
        let row = document.createElement("tr");
        let featureGetter = `is${f.split(" ").join("")}Supported`;
        let isSupported = GPU[featureGetter];
        if (!isSupported)
          row.classList.add("notSupported");
        row.innerHTML = `<td>${f}</td><td>${isSupported}</td>`;
        document.querySelector("table#gpuSupport > tbody")?.appendChild(row);
        gpuSupportTable?.querySelector("tbody")?.appendChild(row);
        gpuSupportTable?.removeAttribute("hidden");
      });
    }
    function addCalcTimeRow(operation) {
      const calcTimeRow = document.createElement("tr");
      calcTimeRow.innerHTML = `<td>${operation}</td>  <td></td> <td></td> <td></td>`;
      calcTimeRow.id = operation.toLowerCase().split(" ").join("-");
      const calcTimeTableBody = document.querySelector("table#performance > tbody");
      return calcTimeTableBody.appendChild(calcTimeRow);
    }
    function getCalcTimeRowCell(rowEl, colName) {
      let idx = { cpu: 1, gpu: 2, gpuCpu: 3 };
      // return document.querySelector(`table#performance tr#${rowId} > td:nth-child(${idx[col]})`)
      return rowEl.children[idx[colName]];
    }
    function runCalcPerfTest(calcName, calc, options) {
      // let { useWorker, silentRun, logPerformance, logResult } = options
      // {targetEl, appendToEl, appendChildToEl}
      if (!options?.silentRun)
        console.log(`%c~ ~ ~ Running ${calcName} ~ ~ ~`, "background-color:cornflowerblue;");
      if (options != undefined) {
        if (options.renderPerformance) {
          options.renderPerformance.targetEL.classList.toggle("running-calc");
          // prettire-ignore
          options.renderPerformance.targetEL.innerHTML = `<div class="d-flex justify-content-center">
                                                          <div class="spinner-border spinner-border-sm" role="status"></div>
                                                        </div>`;
          if (options.renderPerformance.appendToEl)
            options.renderPerformance.appendToEl.append(options.renderPerformance.targetEL);
          else if (options.renderPerformance.appendChildToEl)
            options.renderPerformance.appendChildToEl.appendChild(options.renderPerformance.targetEL);
        }
      }
      if (options?.useWorker) {
      }
      performance.mark(calcName);
      let calcResult = calc.fn.apply(null, calc.fnArgs);
      let perfMeasure = performance.measure(calcName);
      performance.clearMarks(calcName);
      if (options != undefined) {
        if (!options.logPerformance == false) {
          /* Log performance duration by default. Explicitly disable or switch to 'full' */
          if (options.logPerformance == "full")
            console.log(`${calcName} performance:\n`, perfMeasure);
          else
            console.log(`${calcName} duration: ${Math.round(perfMeasure.duration).toLocaleString()} ms`);
        }
        if (!options.logResult == false)
          /* Log calc result by default. Explicitly disable */
          console.log(`${calcName} result:\n`, calcResult);
        if (options.renderPerformance) {
          /* Do not render performance by default */
          options.renderPerformance.targetEL.innerHTML = Math.round(perfMeasure.duration).toLocaleString();
          options.renderPerformance.targetEL.classList.toggle("running-calc");
        }
      }
      if (!options?.silentRun)
        console.info(`%c* * * Finished ${calcName} * * *`, "background-color:orange; color:black");
      return { calcResult, perfMeasure };
    }
    function getCorrectCpms(floatCPMs, resultType = "df") {
      // if (floatCPMs.length == 0) {console.error("floatCpms array is empty"); return}
      const trueCpms = new Float32Array(floatCPMs);
      const maxLevel = trueCpms.length;
      const totalCpmCount = trueCpms.length * 2 - 1;
      let allCpms = Array(totalCpmCount);
      trueCpms.forEach((levelCpm, i) => {
        let level = i + 1;
        allCpms[(level - 1) * 2] = [level, levelCpm];
        if (level < maxLevel) {
          let nextLevelCpm = trueCpms[i + 1];
          let halfLevelCpm = getHalfLevelCPM(levelCpm, nextLevelCpm);
          let halfLevel = level + 0.5;
          allCpms[(halfLevel - 1) * 2] = [halfLevel, halfLevelCpm];
        }
      }, allCpms);
      if (resultType == "df")
        return allCpms;
      return new Map(allCpms);
      function getHalfLevelCPM(levelCpm, nextLevelCpm) {
        let halfLevelCpm = Math.sqrt(levelCpm * levelCpm -
          (levelCpm * levelCpm) / 2 +
          (nextLevelCpm * nextLevelCpm) / 2);
        return halfLevelCpm;
      }
    }
    function createIvMatrix() {
      const ivs = Array(4096);
      {
        // filling iv combos array
        let i = 0;
        console.time("creatIvCombos");
        for (let aI = 0; aI < 16; aI++) {
          for (let dI = 0; dI < 16; dI++) {
            for (let sI = 0; sI < 16; sI++) {
              ivs[i] = [i, aI, dI, sI];
              i++;
            }
          }
        }
        console.timeEnd("creatIvCombos");
      }
      return ivs;
      // console.log(ivs);
    }

    function getCalcCPMsAtCpLimit_CPU(cpLimit, pokeForms, ivs) {
      const atkIdx = 2, defIdx = 3, staIdx = 4;
      const atkIvIdx = 1, defIvIdx = 2, staIvIdx = 3;
      const calcCpms = Array(pokeForms.length);
      for (let pfIdx in pokeForms) {
        calcCpms[pfIdx] = Array(ivs.length);
        for (let ivIdx in ivs) {
          let a = pokeForms[pfIdx][atkIdx] + ivs[ivIdx][atkIvIdx];
          let d = pokeForms[pfIdx][defIdx] + ivs[ivIdx][defIvIdx];
          let s = pokeForms[pfIdx][staIdx] + ivs[ivIdx][staIvIdx];
          calcCpms[pfIdx][ivIdx] = Math.sqrt(((cpLimit + 0.9999999) * 10) / (a * Math.sqrt(d) * Math.sqrt(s)));
        }
      }
      return calcCpms;
    }
    function getTrueCpmsFromCalcCpms_CPU(calcCpms, cpms) {
      const yLength = calcCpms.length; /* number of pokeforms (1 calcCPM set per pokemform) */
      const xLength = calcCpms[0].length; /* number of IV combos per pokeform */
      const lastCpmIdx = cpms.length - 1; /* starting point for reverse scan of CPMs (CPMs length depends on IV_BATCH size) */
      /* create array to hold results, length = # of pokeforms */
      const trueCpms = Array(yLength);
      /* loop through pokeforms */
      for (let y = 0; y < yLength; y++) {
        /* for each pokeform, create nested array for trueCPM results */
        trueCpms[y] = Array(xLength);
        /* loop through calcCPMs of current pokeform */
        for (let x = 0; x < xLength; x++) {
          // trueCpms[y][x] = cpms[0];
          /* for each calcCPM reverse scan CPMs to find max valid CPM (first CPM <= calcCPM) */
          for (let i = lastCpmIdx; i > -1; i--) {
            if (cpms[i][1] <= calcCpms[y][x]) {
              trueCpms[y][x] = cpms[i];
              break;
            }
          }
        }
      }
      return trueCpms;
    }

    function createKernel(gpu, kernelFn, kernelSettings) {
      return gpu.createKernel(kernelFn, kernelSettings);
    }
    function calcCP(pokeForms, ivs, cpms) {
      // prettyier-ignore /* GPU.createKernel notes */
      {
        /**
         * dimensions in .setOutput() are in [x, y, z] order,
         * and correspond to the length of the arrays in the respective thread (this.thread._).
         * multidimensional output will be nested in reverse order:
         * if output is [x,y] -> result will be [y[x]] -> array of length y, with nested arrays of length x
         * if output is [x,y,z] -> result will be [z[y[x]]] -> array of length z, with nested arrays of length y, which also has nested arrays of length x
         **/
        // prettyier-ignore
        /**
         * I want output as [pokemonForms[ivs[cpms]]] so...
         * pokeForms  -> this.thread.z
         * ivs        -> this.thread.y
         * cpms       -> this.thread.x
         **/
        // prettyier-ignore
        /**
         * pokeForms[this.thread.z][2] -> atkBase
         * pokeForms[this.thread.z][3] -> defBase
         * pokeForms[this.thread.z][3] -> staBase
         * ivs[this.thread.y][1] -> atkIv
         * ivs[this.thread.y][2] -> defIv
         * ivs[this.thread.y][3] -> staIv
         * cpms[this.thread.x] -> cpm
         **/
        // prettyier-ignore
        // function calcCp (atk, def, sta, cpm) {
        //   // atk, def, sta are base+IV
        //   return Math.max(10,
        //   ((a * Math.sqrt(d) * Math.sqrt(s) * cpm*cpm )  / 10) >> 0
        // )}
      }
      const atkBaseIdx = 2;
      const defBaseIdx = 3;
      const staBaseIdx = 4;
      const atkIvIdx = 1;
      const defIvIdx = 2;
      const staIvIdx = 3;
      const { x, y, z } = this.thread;
      /*
              x -> iterator for pokeform
              y -> iterator for IVs
              z -> iterator for CPMs
             */
      const a = pokeForms[z][atkBaseIdx] + ivs[y][atkIvIdx];
      const d = pokeForms[z][defBaseIdx] + ivs[y][defIvIdx];
      const s = pokeForms[z][staBaseIdx] + ivs[y][staIvIdx];
      const cpm = cpms[x];
      const cp = Math.max(10, ((a * Math.sqrt(d) * Math.sqrt(s) * cpm * cpm) / 10) >> 0);
      const sp = ((a * cpm * d * cpm * (s * cpm)) >> 0) / 1000;
      // return [a,Math.sqrt(d),Math.sqrt(s),cpm*cpm] //
      // return [pokeForms[this.thread.z][2], ivs[this.thread.y][1], cpms[this.thread.x]]
      return [pokeForms[z][0], cpm, cp, sp];
    }
    function calcCpmsAtCpLimit(cpLimit, pokeForms, ivs) {
      const atkBaseIdx = 2, defBaseIdx = 3, staBaseIdx = 4;
      const atkIvIdx = 1, defIvIdx = 2, staIvIdx = 3;
      const { x, y } = this.thread;
      /*
            x -> iterator for pokeform
            y -> iterator for IVs
           */
      const a = pokeForms[y][atkBaseIdx] + ivs[x][atkIvIdx];
      const d = pokeForms[y][defBaseIdx] + ivs[x][defIvIdx];
      const s = pokeForms[y][staBaseIdx] + ivs[x][staIvIdx];
      const calcCpm = Math.sqrt(((cpLimit + 0.9999999) * 10) / (a * Math.sqrt(d) * Math.sqrt(s)));
      // debugger;
      return calcCpm;
    }
    /** Given calculated CPMs, get index of max valid CPMs/levels  */
    function getTrueCpmIdxsFromCalcCpms(calcCpms, cpms) {
      const startIdx = cpms.length - 1;
      for (let i = startIdx; i > -1; i--) {
        /* go through CPMs in reverse until valid CPM found */
        if (cpms[i] <= calcCpms[this.thread.y][this.thread.x])
          return i;
      }
      return 0;
    }
    function getTrueCpmsFromCpmIdxs(cpmIdxs, cpms) {
      return cpms[cpmIdxs[this.thread.y][this.thread.x]];
    }
    /**
    * @param {*} calcCpms
    * @param {[level: number, cpm: number][]} cpms 2D array, nested items must be [level, CPM]
    * @param {*} lastCpmIdx
    * @param {boolean} returnCPM If true, result includes CPMs. If returnLevel is also true, result is 2D array
    * @param {boolean} returnLevel If true, result includes level. If returnCPM is also true, result is 2D array
    * @returns
    */
    function getTrueCpmsFromCalcCpms(calcCpms, cpms, lastCpmIdx, returnCPM, returnLevel) {
      // debugger;
      if (!returnCPM && !returnLevel)
        return;
      const { x, y } = this.thread;
      /* x -> iterator for pokeform | y -> iterator for IVs*/
      // let i = cpms.length;
      let i = lastCpmIdx;
      while (i > -1 && calcCpms[y][x] < cpms[i][1]) {
        i--;
      }
      if (returnCPM && returnLevel)
        return cpms[i];
      const resultIdx = returnLevel ? 0 : 1;
      return cpms[i][resultIdx]; // return level
      /* For Debugging:
          [current calcCPM, i, first cpm < calcCPM, corresponding level] */
      // return [calcCpms[y][x], i, cpms[i][1], cpms[i][0]]
    }

  </script>
</body>

</html>